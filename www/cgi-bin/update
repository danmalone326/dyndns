#!/usr/bin/python3
import sys
import os
from urllib.parse import parse_qsl, parse_qs
import re
import csv 
import yaml

# sudo pip3 install dnspython
import dns.resolver
import dns.tsigkeyring
import dns.update
import dns

# enable debugging features
debug = False

# we get this from the apache config
ddBaseDir = os.environ.get("DD_BASE_DIR", ".")

authorizedHostsFilename = f"{ddBaseDir}/data/authorizedHosts.csv"
zoneInfoFilename = f"{ddBaseDir}/data/zoneInfo.csv"

# make global
# formFields = cgi.FieldStorage()
# formFields = dict(parse_qsl(os.environ.get("QUERY_STRING", "")))
# changed from parse_qsl to parse_qs to handle multiple txt values
formFields = dict(parse_qs(os.environ.get("QUERY_STRING", "")))

# returns true if the string is an IPv4 Address
def isValidIPv4Address(str):
    try:
        dns.ipv4.inet_aton(str)
        return True
    except:
        return False

# returns true if the string is an IPv6 Address
def isValidIPv6Address(str):
    try:
        dns.ipv6.inet_aton(str, True)
        return True
    except:
        return False
    
def isValidIPAddress(str):
    return isValidIPv4Address(str) or isValidIPv6Address(str)

# returns true if the string is a valid hostname
def isValidHostname(str):
    try:
        # Check if the length of the hostname is within the valid limit
        if (len(str) > 255):
            return False

        # Split the hostname into individual labels
        labels = str.split('.')

        # Check each label for length and validity
        for label in labels:
            if len(label) > 63:
                return False
            
            # regex is not perfect, but handles most scenarios
            if (not re.match(r'^(?:[a-zA-Z0-9_][a-zA-Z0-9-]*)?[a-zA-Z0-9]$', label)):
                return False

        return True

    except:
        return False
    
def getIpList():
    result = []

    # first we'll get all the possible options
    myipAll = formFields.get("myip",[])
    xForwardedFor = os.environ.get("HTTP_X_FORWARDED_FOR",None)
    if (xForwardedFor):
        xForwardedFor = xForwardedFor.split()[-1]
    xClientIP = os.environ.get("HTTP_X_CLIENT_IP",None)
    clientIP = os.environ.get("HTTP_CLIENT_IP",None)
    remoteAddr = os.environ.get("REMOTE_ADDR",None)

    # print(myip)
    # print(xForwardedFor)
    # print(xClientIP)
    # print(clientIP)
    # print(remoteAddr)

    # now we'll pick the first valid one
    result = []
    
    # special case for myip parameter because we allow multiple ips
    # print("myip")
    myipList = []
    if (len(myipAll) > 0):
        for myipOne in myipAll:
            for ip in myipOne.split(','):
                if (isValidIPAddress(ip)):
                    myipList.append(ip)

    if (len(myipList) > 0):
        result = myipList
    elif (isValidIPAddress(xForwardedFor)):
        # print("xForwardedFor")
        result = [xForwardedFor]
    elif (isValidIPAddress(xClientIP)):
        # print("xClientIP")
        result = [xClientIP]
    elif (isValidIPAddress(clientIP)):
        # print("clientIP")
        result = [clientIP]
    elif (isValidIPAddress(remoteAddr)):
        # print("remoteAddr")
        result = [remoteAddr]

    return result

def getHostnameList():
    result = []

    # first we'll get all the options
    hostnameAll = formFields.get("hostname",[])
    if (len(hostnameAll) > 0):
        for hostnameOne in hostnameAll:
            for hostname in hostnameOne.split(','):
                result.append(hostname)

    return result

def getTxtParam():
    # get all the txt parameters and enclose each one in double quotes
    # the update would do this automatically, but we need to compare the results
    # quotes make this complicated
    result = ['"' + str + '"' for str in formFields.get("txt",[])]
    return result
    
allowedDeleteValues = ["A","AAAA","TXT"]
def getDeleteParam():
    result = []
    deleteAll = formFields.get("delete",[])
    if (len(deleteAll) > 0):
        for deleteOne in deleteAll:
            for value in deleteOne.split(','):
                if ((value in allowedDeleteValues) and (value not in result)):
                    result.append(value)
                elif (value == "ALL"):
                    result = allowedDeleteValues
                    break

    return result

def getAuthorizedUser():
    return os.environ.get("REMOTE_USER",None)

def getHostnamePatterns(username):
    result = []
    try:
        with open(authorizedHostsFilename, 'r') as f:
            data = csv.reader(f)

            for row in data:
                if (len(row) == 3):
                    authorizedUser,pattern,zone = row
                    if (authorizedUser == username):
                        rePattern = ("^" + pattern + "$").replace('.','\\.').replace('*','.*')
                        thisPattern = { "regex": rePattern, "zoneName": zone }
                        result.append(thisPattern)
        
        return result

    except:
        problemStop("getHostnamePatterns")
    
def getZoneInfo(zone):
    try:
        with open(zoneInfoFilename, 'r') as f:
            data = csv.reader(f)

            for row in data:
                if (len(row) == 3):
                    name,nameServerIP,keyFile = row
                    if (name == zone):
                        thisZone = { "name": name, "nameServerIP": nameServerIP, "keyFile": keyFile}
                        return thisZone

        problemStop("getZoneInfo 1")     

    except:
        problemStop("getZoneInfo 2")
    
def getHostnameZone(hostname,allowedPatterns):
    for pattern in allowedPatterns:
        if (re.match(pattern["regex"],hostname)):
            return pattern["zoneName"]
    return None

def isAuthorizedHostname(hostname,allowedPatterns):
    zoneName = getHostnameZone(hostname,allowedPatterns)
    if (zoneName is not None):
        return True
    else:
        return False

def getCurrentDNS(hostname,recordType,nameServerIP):
    resolver = dns.resolver.Resolver()
    resolver.nameservers = [nameServerIP]
    resolver.no_recurse = True

    if debug:
        print(resolver.nameservers)

    result = []
    try:
        answers = resolver.query(hostname, rdtype=recordType)
        result.extend(str(answer) for answer in answers)
    except dns.resolver.NXDOMAIN:
        # name does not exist
        pass
    except dns.resolver.NoAnswer:
        # no results for this type
        pass
    except:
        dnserrStop(sys.exc_info()[0])
    
    return result

def getTsigKey(zoneInfo):
    try:
        with open(zoneInfo["keyFile"], 'r') as f:
            data = yaml.load(f)["key"][0]
    except:
        problemStop("getTsigKey")
    return data

def printNoCacheHeaders():
    print("Cache-Control: no-cache, no-store, max-age=0, must-revalidate")
    print("Expires: Mon, 01 Jan 1990 00:00:00 GMT")
    print("Pragma: no-cache")

def stopMessage(str):
    print(str)
    sys.exit(0)

def problemStop(str):
    result = "911"
    if debug:
        result += f" {str}"
    stopMessage(result)

def dnserrStop(str = None):
    if (debug and (str is not None)):
        print(str)
    stopMessage("dnserr")

def checkip():
    print("Content-type: text/plain")
    printNoCacheHeaders()
    print("")

    for ip in getIpList():
        print(ip)

def updateIPs(hostname, ipList, zoneInfo):
    hostnameObj = dns.name.from_text(hostname)
    currentIPs = getCurrentDNS(hostnameObj,"A",zoneInfo["nameServerIP"])
    currentIPs.extend(getCurrentDNS(hostnameObj,"AAAA",zoneInfo["nameServerIP"]))

    if debug:
        print(currentIPs)
        print(ipList)

    currentUnique = set(currentIPs)
    newUnique = set(ipList)
    
    defaultTTL = "30"
    # if there are any differences, we will always do the same
    if (newUnique.symmetric_difference(currentUnique)):
        zoneNameObj = dns.name.from_text(zoneInfo["name"])

        tsigKey = getTsigKey(zoneInfo)
        if debug:
            print(tsigKey)

        keyring = dns.tsigkeyring.from_text({tsigKey["id"]: tsigKey["secret"]})
        keyring["algorithm"] = tsigKey["algorithm"].lower()
        update = dns.update.Update(zoneNameObj, keyring=keyring)

        update.delete(hostnameObj, 'A')
        update.delete(hostnameObj, 'AAAA')

        for ip in newUnique:
            if (isValidIPv4Address(ip)):
                rType = "A"
            else:
                rType = "AAAA"
            update.add(hostnameObj, defaultTTL, rType, ip)

        try: 
            response = dns.query.tcp(update, zoneInfo["nameServerIP"])
            if (response.rcode() == dns.rcode.NOERROR):
                print("good " + ','.join(newUnique))
            else:
                dnserrStop()
        except:
            if debug:
                print("except")
            dnserrStop()

    else:
        # no update needed
        print("nochg " + ','.join(currentIPs))

def updateTXT(hostname, newTXTs, zoneInfo):
    hostnameObj = dns.name.from_text(hostname)
    currentTXTs = getCurrentDNS(hostnameObj,"TXT",zoneInfo["nameServerIP"])

    if debug:
        print(currentTXTs)
        print(newTXTs)

    currentUnique = set(currentTXTs)
    newUnique = set(newTXTs)

    defaultTTL = "0"
    # if there are any differences, we will always do the same
    if (newUnique.symmetric_difference(currentUnique)):
        zoneNameObj = dns.name.from_text(zoneInfo["name"])

        tsigKey = getTsigKey(zoneInfo)
        if debug:
            print(tsigKey)

        keyring = dns.tsigkeyring.from_text({tsigKey["id"]: tsigKey["secret"]})
        keyring["algorithm"] = tsigKey["algorithm"].lower()
        update = dns.update.Update(zoneNameObj, keyring=keyring)

        rType = "TXT"
        update.delete(hostnameObj, rType)
        for txt in newUnique:
            update.add(hostnameObj, defaultTTL, rType, txt)

        try: 
            response = dns.query.tcp(update, zoneInfo["nameServerIP"])
            if (response.rcode() == dns.rcode.NOERROR):
                print("good " + ','.join(newUnique))
            else:
                dnserrStop()
        except:
            if debug:
                print("except")
            dnserrStop()       

    else:
        # no update needed
        print("nochg " + ','.join(currentTXTs))

def delete(hostname, deleteTypes, zoneInfo):
    hostnameObj = dns.name.from_text(hostname)
    deletesNeeded = False
    for type in deleteTypes:
        if (len(getCurrentDNS(hostnameObj,type,zoneInfo["nameServerIP"])) > 0):
            deletesNeeded = True
            break
    
    # if deletes are needed
    if (deletesNeeded):
        zoneNameObj = dns.name.from_text(zoneInfo["name"])

        tsigKey = getTsigKey(zoneInfo)
        if debug:
            print(tsigKey)

        keyring = dns.tsigkeyring.from_text({tsigKey["id"]: tsigKey["secret"]})
        keyring["algorithm"] = tsigKey["algorithm"].lower()
        update = dns.update.Update(zoneNameObj, keyring=keyring)

        for rType in deleteTypes: 
            update.delete(hostnameObj, rType)
        try: 
            response = dns.query.tcp(update, zoneInfo["nameServerIP"])
            if (response.rcode() == dns.rcode.NOERROR):
                print("good")
            else:
                dnserrStop()
        except:
            if debug:
                print("except")
            dnserrStop()        
    else:
        # no update needed
        print("nochg")



def update():
    print("Content-type: text/plain")
    printNoCacheHeaders()
    print("")

    # first need to check for parameter issues
    doUpdateIP = False
    doUpdateTXT = False
    doDelete = False

    actionCount = 0
    action = ""
    if ("txt" in formFields):
        doUpdateTXT = True
        actionCount += 1
    
    if ("delete" in formFields):
        doDelete = True
        actionCount += 1

    if ((actionCount == 0) or ("myip" in formFields)):
        doUpdateIP = True
        actionCount += 1

    if (actionCount > 1):
        stopMessage("badparam")

    username = getAuthorizedUser()
    hostnameList = getHostnameList()
    ipList = getIpList()
    txtParam = getTxtParam()
    deleteTypes = getDeleteParam()

    if (len(hostnameList) == 0):
        stopMessage("notfqdn")

    if (len(hostnameList) > 20):
        stopMessage("numhost")

    if (len(ipList) > 20):
        stopMessage("numip")

    allowedPatterns = getHostnamePatterns(username)
    for hostname in hostnameList:
        if debug:
            print(hostname)
        # check hostname (notfqdn)
        if (not isValidHostname(hostname)):
            print("notfqdn")
        # check hostname authorization (nohost,abuse)
        else:
            zoneName = getHostnameZone(hostname,allowedPatterns)
            if (zoneName is None):
                print("nohost")
            else:
                zoneInfo = getZoneInfo(zoneName)
                # print("good")
                # print(zoneInfo)
                if (doUpdateIP):
                    # set ips
                    updateIPs(hostname, ipList, zoneInfo)
                elif (doUpdateTXT):
                    # set txt
                    updateTXT(hostname, txtParam, zoneInfo)
                elif (doDelete):
                    # do delete
                    delete(hostname, deleteTypes, zoneInfo)

    


def checkParams():
    print("Content-type: text/plain")
    printNoCacheHeaders()
    print("")

    print("Hostnames:")
    hostnameList = getHostnameList()
    for hostname in hostnameList:
        print(hostname)

    print("")
    print("Valid IPs:")
    ipList = getIpList()
    for ip in ipList:
        print(ip)

    print("")
    print("TXT:")
    txtParam = getTxtParam()
    print(txtParam)

    print("")
    print("Delete:")
    deleteParam = getDeleteParam()
    print(deleteParam)

    print("")

def print_variable(name, value):
    print(f'<li><strong>{name}:</strong> {value}</li>')

def debugHTML():
    print("Content-type: text/html")
    printNoCacheHeaders()
    print("")

    print("<html><head>")
    print("<title>Server Variables and CGI Parameters</title>")
    print("<link rel='icon' href='data:,'>")
    print("</head><body>")
    print("<h1>Server Variables and CGI Parameters</h1>")
    print("<ul>")
    
    # Server Variables
    print("<h2>Server Variables</h2>")
    for key, value in os.environ.items():
        print_variable(key, value)
    
    # CGI Parameters
    print("<h2>CGI Parameters</h2>")
    for key in formFields:
        print_variable(key, formFields[key])
        
    print("</ul>")

    if ("myip" in formFields):
        for ip in getIpList():
            print(ip)
            if (isValidIPv4Address(ip)):
                print("IPv4")
            elif (isValidIPv6Address(ip)):
                print("IPv6")
            else:
                print("not IP")
            print("<br>")

    print("</body></html>")


def main():
    SCRIPT_NAME = ""
    if ("SCRIPT_NAME" in os.environ):
        SCRIPT_NAME = os.environ["SCRIPT_NAME"]

    if (SCRIPT_NAME == "/checkip"):
        checkip()
    elif (SCRIPT_NAME == "/update"):
        update()
    else:
        if debug:
            if (SCRIPT_NAME == "/checkparams"):
                checkParams()
            elif (SCRIPT_NAME == "/err"):
                print("you should never see this")
            else:
                debugHTML()
        else:
            stopMessage("badop")

if __name__ == "__main__":
    try:
        main()

    # this needs to be removed before productionalizing 
    except Exception as e:
        if debug:
            # Print the exception information to stdout
            print("An exception occurred:")
            print(f"Type: {type(e).__name__}")
            print(f"Message: {str(e)}")
            print("Traceback (most recent call last):")
            traceback = sys.exc_info()[2]
            for frame in traceback.tb_next:
                print(f'  File "{frame.tb_frame.f_code.co_filename}", line {frame.tb_lineno}, in {frame.tb_frame.f_code.co_name}')
                print(f'    {frame.tb_frame.f_code.co_name}({", ".join(repr(arg) for arg in frame.tb_frame.f_code.co_varnames)})')
            print(f"{type(e).__name__}: {str(e)}")
        else:
            problemStop()

